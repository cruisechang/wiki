# 演算法推估基礎
    當兩個函式逐漸增長之後，
    兩者差距越來越大，
    此時我們可以忽略函式中的常數，
    只考慮最高次項的階數。

#### 範例
```
演素法 A=2n^2+1
演算法 B=3n^3+2n

當 n=10000之後，
Ａ演算法的 +1，跟 B 演算法的 +2n 影響都極小，
因此可以忽略。
```

# Tme Complexity
### `演算法的漸進時間複雜度(時間複雜度)`

假設 f(n) 是問題規模 n 的某個函式

隨著問題規模 n 增大，演算法所需的執行時間跟 f(n) 執行次數同步增長，

因此 f(n) 的複雜度決定了整個問題的執行時間。

我們要找出的就是讓 f(n) 的執行次數增加最慢的算法。

就是時間複雜度最低的算法。


### `常見時間複雜度表`
|效率| 執行次數函式  | 階  | 非正式術語  |
|:-:|:-:|:-:|:-:|
|1| 12  | O(1)  |  常數階 |
|2| 5log~2~n+20  | O(log n)  | 對數階  |
|3| 2n+3  | O(n)  | 線性階  |
|4| 2n+3nlog~2~n+19  | O(n log n)  | nlog~2~n階（n對數階）|
|5| 3n^2+2n+1  | O(n^2)  | 平方階  |
|6| 6n^3+2n^2+3n+4  | O(n^3)  | 立方階  |
|7| n!  | O(n!)  | 階層階  |
|8| 2^n  | O(2^n)  | 指數階  |


效率
```
O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) <O(n^n)


1 < log n < n < n log n < n^2 < n^3 < < n! < 2^n
```